// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider          = "mysql"
    url               = env("DATABASE_URL")
    shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Users {
    id             String  @id @default(uuid())
    email          String  @unique
    emailVerified  Boolean @default(false)
    firstName      String
    lastName       String
    username       String? @unique
    profilePhoto   String?
    profilePhotoId String?
    coverPhoto     String?
    coverPhotoId   String?
    phone          String?
    password       String
    occupation     String?
    bio            String?

    facebookUrl  String?
    twitterUrl   String?
    instagramUrl String?
    linkedinUrl  String?

    followersCount Int         @default(0)
    followingCount Int         @default(0)
    eventsCount    Int         @default(0)
    ticketsCount   Int         @default(0)
    bookmarksCount Int         @default(0)
    favoritesCount Int         @default(0)
    bookmarks      Bookmarks[]
    favorites      Favorites[]
    followers      Follows[]   @relation("Follower")
    following      Follows[]   @relation("Following")

    isVerified             Boolean @default(false)
    isBlocked              Boolean @default(false)
    isSuspended            Boolean @default(false)
    isDeleted              Boolean @default(false)
    isSuperAdmin           Boolean @default(false)
    isSubscribed           Boolean @default(false)
    isNewsletterSubscribed Boolean @default(false)

    TicketOrdersCount Int            @default(0)
    TicketOrders      TicketOrders[]

    createdAt DateTime?  @default(now())
    updatedAt DateTime?  @updatedAt
    events    Events[]
    Payment   Payments[]

    @@map("Users")
}

model Events {
    id          String @id @default(uuid())
    eventId     String
    user        Users  @relation(fields: [publisherId], references: [id])
    publisherId String

    title       String
    description String
    location    Locations?      @relation(fields: [locationId], references: [id])
    locationId  String?
    venue       String?
    date        DateTime
    time        String
    category    String          @default("General")
    tags        TagsForEvents[]
    visibility  EventVisibility @default(PUBLIC)

    mainImageUrl String
    mainImageId  String
    images       EventImages[]

    currency          String    @default("NGN")
    tickets           Tickets[]
    purchaseStartDate DateTime
    purchaseEndDate   DateTime
    allowedGuestType  String    @default("Everyone")

    bookmarksCount    Int            @default(0)
    favoritesCount    Int            @default(0)
    bookmarks         Bookmarks[]
    favorites         Favorites[]
    TicketOrdersCount Int            @default(0)
    TicketOrders      TicketOrders[]

    createdAt DateTime? @default(now())
    updatedAt DateTime? @updatedAt

    @@map("Events")
}

model Bookmarks {
    id        String    @id @default(uuid())
    user      Users     @relation(fields: [userId], references: [id])
    userId    String
    event     Events    @relation(fields: [eventId], references: [id])
    eventId   String
    createdAt DateTime? @default(now())
    updatedAt DateTime? @updatedAt

    @@map("Bookmarks")
}

model Favorites {
    id        String    @id @default(uuid())
    user      Users     @relation(fields: [userId], references: [id])
    userId    String
    event     Events    @relation(fields: [eventId], references: [id])
    eventId   String
    createdAt DateTime? @default(now())
    updatedAt DateTime? @updatedAt

    @@map("Favorites")
}

/// OrderedTickets model
/// The OrderedTickets model is used to store details of tickets ordered by users.
/// The OrderedTickets model includes a ticket field, defining the reverse relationship between OrderedTickets and Tickets.
model OrderedTickets {
    id              String       @id @default(uuid())
    ticket          Tickets      @relation(fields: [ticketId], references: [id])
    ticketId        String
    orderId         String       
    order           TicketOrders @relation(fields: [orderId], references: [id])
    associatedEmail String?
    contactEmail    String
    price           Decimal
    orderStatus     OrderStatus
    paymentId       String?      
    createdAt       DateTime?    @default(now())
    updatedAt       DateTime?    @updatedAt

    @@map("OrderedTickets")
}

/// TicketOrders model
/// The TicketOrders model is used to store details of ticket orders placed by users.
/// The TicketOrders model includes a payments field, defining the reverse relationship between TicketOrders and Payment.
/// The payments field in TicketOrders is annotated with @relation("TicketOrderPayments") to specify the relationship name.
/// Each ticket order can have multiple associated payments allowing you to track payment transactions for each order efficiently, so the relationship is defined as a one-to-many relationship.
model TicketOrders {
    id         String           @id @default(uuid())
    user       Users            @relation(fields: [userId], references: [id])
    userId     String
    event      Events           @relation(fields: [eventId], references: [id])
    eventId    String
    tickets    OrderedTickets[]
    quantity   Int
    totalPrice Decimal

    contactEmail  String
    orderId       String        @default(uuid())
    orderStatus   OrderStatus
    paymentStatus PaymentStatus
    paymentId     String?       
    payments      Payments[]    @relation("TicketOrderPayments")

    createdAt DateTime? @default(now())
    updatedAt DateTime? @updatedAt

    @@map("TicketOrders")
}

/// Payment model
/// This model is used to store payment details for each ticket order.
/// The Payment model includes a ticketOrder field, establishing a one-to-many relationship between TicketOrders and Payment.
/// The ticketOrderId field in the Payment model references the id field of the TicketOrders model, establishing the foreign key constraint.
model Payments {
    id            String        @id @default(uuid())
    user          Users         @relation(fields: [userId], references: [id])
    userId        String
    // ticketOrder   TicketOrders  @relation(fields: [ticketOrderId], references: [id])
    ticketOrder   TicketOrders  @relation("TicketOrderPayments", fields: [ticketOrderId], references: [id])
    ticketOrderId String
    amount        Decimal
    amountPaid    Decimal?
    currency      String
    paymentStatus PaymentStatus
    paymentId     String
    paymentMethod String
    createdAt     DateTime?     @default(now())
    updatedAt     DateTime?     @updatedAt

    @@map("Payment")
}

model Follows {
    follower    Users     @relation("Follower", fields: [followerId], references: [id])
    followerId  String
    following   Users     @relation("Following", fields: [followingId], references: [id])
    followingId String
    createdAt   DateTime? @default(now())
    updatedAt   DateTime? @updatedAt

    @@id([followerId, followingId])
    @@map("Follows")
}

model NewsLetterSubscribers {
    id        String    @id @default(uuid())
    email     String    @unique
    createdAt DateTime? @default(now())
    updatedAt DateTime? @updatedAt

    @@map("NewsLetterSubscribers")
}

model Locations {
    id        String    @id @default(uuid())
    address   String
    city      String
    state     String
    country   String
    zipCode   String?
    createdAt DateTime? @default(now())
    updatedAt DateTime? @updatedAt
    events    Events[]

    @@map("Locations")
}

enum EventVisibility {
    PUBLIC
    PRIVATE

    @@map("EventVisibility")
}

enum OrderStatus {
    Pending
    Confirmed
    Cancelled
}

enum PaymentStatus {
    Pending
    Paid
    Failed
}

model EventImages {
    id       String @id @default(uuid())
    imageUrl String
    imageId  String
    event    Events @relation(fields: [eventId], references: [id], onDelete: Cascade)
    eventId  String

    @@map("EventImages")
}

model Tickets {
    id                String           @id @default(uuid())
    event             Events           @relation(fields: [eventId], references: [id], onDelete: Cascade)
    eventId           String
    name              String
    price             Decimal
    quantity          Int
    remainingTickets  Int              @default(0)
    numberOfUsers     Int
    description       String?
    TicketOrdersCount Int              @default(0)
    TicketOrders      OrderedTickets[]
    createdAt         DateTime?        @default(now())
    updatedAt         DateTime?        @updatedAt

    @@map("Tickets")
}

model Tags {
    id     String          @id @default(uuid())
    name   String
    events TagsForEvents[]

    @@map("Tags")
}

model TagsForEvents {
    eventId String
    tagId   String

    // Relationships with Event and Tag models
    event Events @relation(fields: [eventId], references: [id], onDelete: Cascade)
    tag   Tags   @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@id([eventId, tagId])
    @@map("TagsForEvents")
}
